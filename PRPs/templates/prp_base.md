---
# YAML Front Matter: Populated by the initial context-gathering script.
project_name: "{GENERATED_PROJECT_NAME}" # Generated from INITIAL.md/docs/etc.
project_slug: "{generated_project_slug}" # Machine-friendly version of the project name.
primary_language: "{DETECTED_LANGUAGE}" # Detected from file analysis (e.g., .py, .js, .rs).
status: "planning" # Initial state for a new PRP.
version: "0.1.0"
generated_at: "{TIMESTAMP}"
source_files: ["{SOURCE_FILES_LIST}"]
---

<!-- SECTION: CorePrinciples -->
## Core Principles (Static - Do Not Change)
1.  **Context is King**: Include ALL necessary documentation, examples, and caveats.
2.  **Validation Loops**: Provide executable tests/lints the AI can run and fix.
3.  **Information Dense**: Use keywords and patterns from the codebase.
4.  **Progressive Success**: Start simple, validate, then enhance.
5.  **Global Rules**: Follow all rules in the master system prompt (e.g., CLAUDE.md).

---

<!-- SECTION: Goal -->
## Goal
*(To be generated by agents based on project context)*
A clear, concise statement of what needs to be built.

<!-- SECTION: Why -->
## Why
*(To be generated by agents based on project context)*
- The business value or user problem this solves.
- How it integrates with or improves existing features.

<!-- SECTION: What -->
## What
*(To be generated by agents based on project context)*
A description of user-visible behavior and core technical requirements.

### Success Criteria
*(To be generated by agents)*
- [ ] A specific, measurable, and testable outcome.
- [ ] Another specific, measurable, and testable outcome.

---

<!-- SECTION: AllNeededContext -->
## All Needed Context
*(To be enhanced by agents)*

### Documentation & References
```yaml
# MUST READ - Core technical documentation. Paths use the {generated_project_slug} placeholder.
- url: https://official-docs.example.com/api
  why: Describes the core API methods we must use.
- file: workspace/{generated_project_slug}/src/existing_pattern.py
  why: The existing pattern for all new modules to follow.
- docfile: docs/user_provided_architecture.md
  why: The user's high-level plan for the project.
```

### Desired Codebase Tree
```bash
# The target file structure. The {generated_project_slug} is replaced by the script.
workspace/{generated_project_slug}/
├── src/
│   └── new_feature.py
└── tests/
    └── test_new_feature.py
```

### Known Gotchas & Library Quirks
```python
# CRITICAL: Key-value pairs of things to watch out for, specific to the project's tech stack.
# Example Pydantic V2: Use `model_config` instead of `Config` inner class.
# Example Asyncio: Never call `asyncio.run()` inside a running event loop.
```

---

<!-- SECTION: ImplementationBlueprint -->
## Implementation Blueprint
*(To be generated and refined by agents)*

### Data Models & Structure
```python
# Pydantic models, ORM classes, or other data structures will be defined here.
# Example:
from pydantic import BaseModel, Field

class NewFeatureRequest(BaseModel):
    user_id: int
    data: str = Field(..., max_length=100)
```

### Task Breakdown (Ordered)
```yaml
# A parsable list of implementation tasks. All paths use the placeholder.
- task: 1
  action: CREATE
  path: workspace/{generated_project_slug}/src/new_feature.py
  details:
    - Implement the `NewFeature` class.
    - Add methods `process_data` and `validate_input`.
  pseudocode: |
    # PATTERN: Use the existing validator from `utils.py`.
    class NewFeature:
        def process_data(self, data):
            # GOTCHA: The external API has a rate limit of 10 req/s.
            # CRITICAL: Use the global rate limiter instance.
            ...

- task: 2
  action: MODIFY
  path: workspace/{generated_project_slug}/src/main.py
  details:
    - Import and integrate the `NewFeature` class.
```

### Integration Points
```yaml
# How the new code connects to the existing system.
CONFIG:
  - path: workspace/{generated_project_slug}/config/settings.py
    pattern: "NEW_FEATURE_ENABLED = bool(os.getenv('NEW_FEATURE_ENABLED', 'False'))"
DATABASE:
  - migration: "Add 'new_feature_data' column to 'items' table."
```

---

<!-- SECTION: ValidationLoop -->
## Validation Loop
*(To be generated and refined by agents)*

### Level 1: Syntax & Style
```bash
# Commands to run first. Paths use the placeholder. Must pass before proceeding.
ruff check workspace/{generated_project_slug}/ --fix
mypy workspace/{generated_project_slug}/src/
```

### Level 2: Unit Tests
```python
# Test cases for new code. Path uses the placeholder.
# CREATE: workspace/{generated_project_slug}/tests/test_new_feature.py
def test_new_feature_happy_path():
    # ...
    pass

def test_new_feature_edge_case():
    # ...
    pass
```
```bash
# Command to run the tests.
pytest workspace/{generated_project_slug}/tests/test_new_feature.py -v
```

### Level 3: Integration Test
```bash
# Command to test the full system integration.
curl -X POST http://localhost:8000/new-feature -d '{"data": "test"}'
# Expected: {"status": "success"}
```

### Final Validation Checklist
- [ ] All Level 1, 2, and 3 validation steps pass.
- [ ] Error cases are handled gracefully.
- [ ] Documentation updated if needed.

---

<!-- SECTION: AntiPatterns -->
## Anti-Patterns to Avoid (Static - Do Not Change)
- ❌ Don't create new patterns when existing ones work.
- ❌ Don't skip validation because "it should work."
- ❌ Don't ignore failing tests—fix them at the source.
- ❌ Don't use synchronous functions in an asynchronous context.
- ❌ Don't hardcode values that should be in config.
- ❌ Don't hallucinate; generate code based on factual information from the provided files and context.
- ❌ Don't exceed 500 lines per file; refactor into smaller, logical modules.
